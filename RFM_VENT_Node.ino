// RFM69 VENT node sketch
//
// This node talks to the MQTT-Gateway and will:
// - send sensor data periodically and on-demand
// - receive commands from the gateway to control actuators
// - receive commands from the gateway to change settings
//
// Several nodes can operate within a single network; each have a unique node ID.
// On startup the node operates with default values, set on compilation.
//
// Hardware used is a 3.3 Volt 8MHz arduino Pro; this is easier to interface to RFM69
//
//
// Message format is: nodeID/deviceID/command/integer/float/string
//
// Depending on the type of data (integer, float or string) one of the payload variables is used
// Command = 0 means write a value in the node, cmd = 1 means read a value
//
// Current defined devices are:
//
//	0	uptime:			read uptime node in minutes
//	1	node:		    read/set transmission interval in seconds, 0 means no periodic transmission
//	2	RSSI:			  read radio signal strength
//	3	Version:		read version node software
//	4	voltage:		read battery level
//	5	ACK:			  read/set acknowledge message after a 'set' request
//	9	retry:			read number of retransmissions needed in radiolink//
//	16	ACT1:		read/set BOOST setting
//  17  ACT2:     read/set OVERPRESSURE setting
//  32  VAL1:     read/set ROOM temp
//  33  VAL2:     read/set ROOM hum
//  34  VAL3:     read/set ROOM CO2
//	90	error:			tx only: error message if no wireless connection (generated by gateway)
//	92	error:			tx only: device not supported
//	99	wakeup:			tx only: first message sent on node startup
//
//
//	A debug mode is included which outputs messages on the serial output
//
//	RFM69 Library by Felix Rusu - felix@lowpowerlab.com
//	Get the RFM69 library at: https://github.com/LowPowerLab/
//
//	version 1.7 by Computourist@gmail.com december 2014
//	version 2.0 increased payload size; implemented node uptime; standard device type convention; error handling .
//	version 2.1 removed device 8; changed handling of device 40; compatible with gateway V2.2	; march 2015
//	version 2.2 fixed bug in function TXradio that prevented retransmission of radio packets ; oct 2015

#include <RFM69.h>
#include <SPI.h>

//
// CONFIGURATION PARAMETERS
//
#define NODEID 3 					// unique node ID within the closed network
#define GATEWAYID 1					// node ID of the Gateway is always 1
#define NETWORKID 100					// network ID of the network
#define ENCRYPTKEY "xxxxxxxxxxxxxxxx" 			// 16-char encryption key; same as on Gateway!
#define DEBUG						// uncomment for debugging
#define VERSION "VENT Node V1.0"				// this value can be queried as device 3

// Wireless settings	Match frequency to the hardware version of the radio

//#define FREQUENCY RF69_433MHZ
#define FREQUENCY RF69_868MHZ
//#define FREQUENCY RF69_915MHZ

#define IS_RFM69HW 					// uncomment only for RFM69HW! 
#define ACK_TIME 50 					// max # of ms to wait for an ack

// sensor setting
#define ACT1 9						// Actuator pin (LED or relay)
#define ACT2 8
#define VAL1 7
#define VAL2 6
#define VAL3 5
#define SERIAL_BAUD 115200
#define HOLDOFF 2000					// blocking period between button messages

//
//	STARTUP DEFAULTS
//
long 	TXinterval = 60;				// periodic transmission interval in seconds

//
//	VARIABLES
//
long	lastPeriod = -1;				// timestamp last transmission
long	lastMinute = -1;				// timestamp last minute
long	upTime = 0;					// uptime in minutes
int  ACT1State;          // status ACT1 output
int  ACT2State;          // status ACT2 output
int  VAL1State;          // status VAL1 output
int  VAL2State;          // status VAL2 output
int  VAL3State;          // status VAL3 output
int	signalStrength;					// radio signal strength
bool	setAck = true;					// send ACK message on 'SET' request
bool	send0, send1, send2, send3, send4;
bool	send5, send9, send16, send17;
bool	send32, send33, send34, send92;		// message triggers
bool	promiscuousMode = false; 			// only listen to nodes within the closed network
bool 	wakeUp = true;					// wakeup flag
bool	msgBlock = false;				// flag to hold button messages to prevent overload
bool	retx = true; 					// flag to signal retransmission
int	numtx;							// number of retransmissions



typedef struct {					// Radio packet format
  int	nodeID;						// node identifier
  int	devID;						// device identifier
  int	cmd;						// read or write
  long	intVal;						// integer payload
  float	fltVal;						// floating payload
  char	payLoad[32];					// string payload
} Message;

Message mes;

RFM69 radio;

//
//=====================		SETUP	========================================
//
void setup() {
#ifdef DEBUG
  Serial.begin(SERIAL_BAUD);
#endif
  pinMode(ACT1, OUTPUT);					// set actuator 1
  ACT1State = 0;
  digitalWrite(ACT1, ACT1State);
  pinMode(ACT2, OUTPUT);          // set actuator 1
  ACT2State = 0;
  digitalWrite(ACT2, ACT2State);
  pinMode(VAL1, OUTPUT);          // set actuator 1
  VAL1State = 0;
  analogWrite(VAL1, VAL1State);
  pinMode(VAL2, OUTPUT);          // set actuator 1
  VAL2State = 0;
  analogWrite(VAL2, VAL2State);
  pinMode(VAL3, OUTPUT);          // set actuator 1
  VAL3State = 0;
  analogWrite(VAL3, VAL3State);
  radio.initialize(FREQUENCY, NODEID, NETWORKID);		// initialise radio
#ifdef IS_RFM69HW
  radio.setHighPower(); 					// only for RFM69HW!
#endif
  radio.encrypt(ENCRYPTKEY);				// set radio encryption
  radio.promiscuous(promiscuousMode);			// only listen to closed network
  wakeUp = true;						// send wakeup message

#ifdef DEBUG
  Serial.print("Node Software Version ");
  Serial.println(VERSION);
  Serial.print("\nTransmitting at ");
  Serial.print(FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
  Serial.println(" Mhz...");
#endif
}	// end setup

//
//
//====================		MAIN	========================================
//
void loop() {
  // RECEIVE radio input
  //
  if (receiveData()) parseCmd();				// receive and parse any radio input

  // UPTIME
  //

  if (lastMinute != (millis() / 60000)) {			// another minute passed ?
    lastMinute = millis() / 60000;
    upTime++;
  }

  // PERIODIC TRANSMISSION
  //

  if (TXinterval > 0)
  {
    int currPeriod = millis() / (TXinterval * 1000);
    if (currPeriod != lastPeriod) {				// interval elapsed ?
      lastPeriod = currPeriod;

      // list of sensordata to be sent periodically..
      // remove comment to include parameter in transmission

      //	send1 = true;					// send transmission interval
      send2 = true; 					// signal strength
      send4 = true;					// voltage level
      //	send9 = true;					// number of retransmissions
      send16 = true;					// actuator state
      send17 = true;
      send32 = true;					// send temperature
      send33 = true;          // send hum
      send34 = true;          // send co2
    }
  }

  // SEND RADIO PACKETS
  //

  sendMsg();						// send any radio messages

}		// end loop

//
//
//=====================		FUNCTIONS	==========================================

//
//========		RECEIVEDATA : receive data from gateway over radio
//

bool receiveData() {
  bool validPacket = false;
  if (radio.receiveDone())				// check for received packets
  {
    if (radio.DATALEN != sizeof(mes))			// wrong message size means trouble
#ifdef DEBUG
      Serial.println("invalid message structure..")
#endif
      ;
    else
    {
      mes = *(Message*)radio.DATA;
      validPacket = true;				// YES, we have a packet !
      signalStrength = radio.RSSI;
#ifdef DEBUG
      Serial.print(mes.devID);
      Serial.print(", ");
      Serial.print(mes.cmd);
      Serial.print(", ");
      Serial.print(mes.intVal);
      Serial.print(", ");
      Serial.print(mes.fltVal);
      Serial.print(", RSSI= ");
      Serial.println(radio.RSSI);
      Serial.print("Node: ");
      Serial.println(mes.nodeID);
#endif
    }
  }
  if (radio.ACKRequested()) radio.sendACK();		// respond to any ACK request
  return validPacket;					// return code indicates packet received
}		// end recieveData

//
//
//==============		PARSECMD: analyse messages and execute commands received from gateway
//

void parseCmd() {					// parse messages received from the gateway
  send0 = false;						// initialise all send triggers
  send1 = false;
  send2 = false;
  send3 = false;
  send4 = false;
  send5 = false;
  send9 = false;
  send16 = false;
  send17 = false;
  send32 = false;
  send33 = false;
  send34 = false;
  send92 = false;

  switch (mes.devID)					// devID indicates device (sensor) type
  {
    case (0):						// uptime
      if (mes.cmd == 1) send0 = true;
      break;
    case (1):						// polling interval in seconds
      if (mes.cmd == 0) {					// cmd == 0 means write a value
        TXinterval = mes.intVal;			// change interval to radio packet value
        if (TXinterval < 10 && TXinterval != 0) TXinterval = 10;	// minimum interval is 10 seconds
        if (setAck) send1 = true;			// send message if required
#ifdef DEBUG
        Serial.print("Setting interval to ");
        Serial.print(TXinterval);
        Serial.println(" seconds");
#endif
      }
      else send1 = true;					// cmd == 1 is a read request, so send polling interval
      break;
    case (2): 						// signal strength
      if (mes.cmd == 1) send2 = true;
      break;
    case (3): 						// software version
      if (mes.cmd == 1) send3 = true;
      break;
    case (4): 						// battery level
      if (mes.cmd == 1) send4 = true;
      break;
    case (5): 						// set ack status
      if (mes.cmd == 0) {
        if (mes.intVal == 0) setAck = false;
        if (mes.intVal == 1) setAck = true;
        if (setAck) send5 = true;			// acknowledge message ?
      }
      else send5 = true;					// read request means schedule a message
      break;
    case (9):						// retransmissions
      if (mes.cmd == 1) send9 = true;
      break;
    case (16):						// Actuator 1
      if (mes.cmd == 0) {					// cmd == 0 means write
        if (mes.intVal == 0 || mes.intVal == 1) {
          ACT1State = mes.intVal;
          digitalWrite(ACT1, ACT1State);
          if (setAck) send16 = true;			// acknowledge message ?
#ifdef DEBUG
          Serial.print("Set BOOST to ");
          Serial.println(ACT1State);
#endif
        }
      }
      else send16 = true;					// cmd == 1 means read
      break;
      case (17):            // Actuator 2
      if (mes.cmd == 0) {         // cmd == 0 means write
        if (mes.intVal == 0 || mes.intVal == 1) {
          ACT2State = mes.intVal;
          digitalWrite(ACT2, ACT2State);
          if (setAck) send17 = true;      // acknowledge message ?
#ifdef DEBUG
          Serial.print("Set OVERPRESSURE to ");
          Serial.println(ACT2State);
#endif
        }
      }
      else send17 = true;         // cmd == 1 means read
      break;
      case (32):            // TEMP
      if (mes.cmd == 0) {         // cmd == 0 means write
        if (mes.intVal >= 0 || mes.intVal <= 255) {
          VAL1State = mes.intVal;
          analogWrite(VAL1, VAL1State);
          if (setAck) send32 = true;      // acknowledge message ?
#ifdef DEBUG
          Serial.print("Set TEMP to ");
          Serial.println(VAL1State);
#endif
        }
      }
      else send32 = true;         // cmd == 1 means read
      break;
      case (33):            // HUM
      if (mes.cmd == 0) {         // cmd == 0 means write
        if (mes.intVal >= 0 || mes.intVal <= 255) {
          VAL1State = mes.intVal;
          analogWrite(VAL2, VAL2State);
          if (setAck) send33 = true;      // acknowledge message ?
#ifdef DEBUG
          Serial.print("Set HUM to ");
          Serial.println(VAL2State);
#endif
        }
      }
      else send33 = true;         // cmd == 1 means read
      break;
      case (34):            // CO2
      if (mes.cmd == 0) {         // cmd == 0 means write
        if (mes.intVal >= 0 || mes.intVal <= 255) {
          VAL1State = mes.intVal;
          analogWrite(VAL3, VAL3State);
          if (setAck) send34 = true;      // acknowledge message ?
#ifdef DEBUG
          Serial.print("Set CO2 to ");
          Serial.println(VAL3State);
#endif
        }
      }
      else send33 = true;         // cmd == 1 means read
      break;
    default: send92 = true;					// no valid device parsed
  }
}	// end parseCmd

//
//
//======================		SENDMSG: sends messages that are flagged for transmission
//

void sendMsg() {					// prepares values to be transmitted
  bool tx = false; 					// transmission flag
  mes.nodeID = NODEID;
  mes.intVal = 0;
  mes.fltVal = 0;
  mes.cmd = 0;						// '0' means no action needed in gateway
  int i;
  for ( i = 0; i < sizeof(VERSION); i++) {
    mes.payLoad[i] = VERSION[i];
  }
  mes.payLoad[i] = '\0';					// software version in payload string

  if (wakeUp) {						// send wakeUp call
    mes.devID = 99;
    wakeUp = false;					// reset transmission flag for this message
    txRadio();					// transmit
  }
  if (send0) {
    mes.devID = 0;
    mes.intVal = upTime;				// minutes uptime
    send0 = false;
    txRadio();
  }
  if (send1) {						// transmission interval
    mes.devID = 1;
    mes.intVal = TXinterval;			// seconds (integer)
    send1 = false;
    txRadio();
  }
  if (send2) {
    mes.devID = 2;
    mes.intVal = signalStrength;			// signal strength (integer)
    send2 = false;
    txRadio();
  }
  if (send3) {						// node software version (string)
    mes.devID = 3;					// already stored in payload string
    send3 = false;
    txRadio();
  }
  if (send4) {						// measure voltage..
    mes.devID = 4;
    long result;					// Read 1.1V reference against AVcc
    ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
    delay(2);					// Wait for Vref to settle
    ADCSRA |= _BV(ADSC);				// Convert
    while (bit_is_set(ADCSRA, ADSC));
    result = ADCL;
    result |= ADCH << 8;
    result = 1126400L / result; 			// Back-calculate in mV
    mes.fltVal = float(result / 1000.0);		// Voltage in Volt (float)
    txRadio();
    send4 = false;
  }
  if (send5) {						// Acknowledge on 'SET'
    mes.devID = 5;
    if (setAck) mes.intVal = 1; else mes.intVal = 0;// state (integer)
    send5 = false;
    txRadio();
  }
  if (send9) {						// number of retransmissions
    mes.devID = 9;
    mes.intVal = numtx;			// number (integer)
    send9 = false;
    txRadio();
  }
  if (send16) {						// state of Boost
    mes.devID = 16;
    mes.intVal = ACT1State;				// state (integer)
    send16 = false;
    txRadio();
  }
  if (send17) {            // state of Overpressure
    mes.devID = 17;
    mes.intVal = ACT2State;       // state (integer)
    send17 = false;
    txRadio();
  }
  if (send32) {            // state of Temperature
    mes.devID = 32;
    mes.intVal = VAL1State;       // state (integer)
    send32 = false;
    txRadio();
  }
  if (send33) {            // state of Humidity
    mes.devID = 33;
    mes.intVal = VAL2State;       // state (integer)
    send33 = false;
    txRadio();
  }
  if (send34) {            // state of CO2
    mes.devID = 34;
    mes.intVal = VAL3State;       // state (integer)
    send34 = false;
    txRadio();
  }
  if (send92) {						// error message invalid device
    mes.intVal = mes.devID;
    mes.devID = 92;
    send92 = false;
    txRadio();
  }

}
//
//
//=======================		TXRADIO
//

void txRadio()						// Transmits the 'mes'-struct to the gateway
{
  retx = true;
  int i = 0;

  while (retx && i < 6) {
    if (radio.sendWithRetry(GATEWAYID, (const void*)(&mes), sizeof(mes), 5)) {
      retx = false;
#ifdef DEBUG
      Serial.print(" message ");
      Serial.print(mes.devID);
      Serial.println(" sent...");
#endif
    } else delay(500);
    i++;
  }
  numtx = i;							// store number of retransmissions needed
#ifdef DEBUG
  if (retx) Serial.println("No connection...")
#endif
    ;
}	// end txRadio






